---
title: "Ã¥ngstromCTF 2021 - Home Rolled Crypto"
emoji: "ğŸ˜¸"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Crypto", "CTF", "Med"]
published: true
---

### å•é¡Œæ¦‚è¦
> Aplet made his own block cipher! Can you break it?
>
> `nc crypto.2021.chall.actf.co 21602`
> [Source](https://files.actf.co/8032b67e489c4fbeb8cb98f8bc18eec7ddf6639ce8bd6a7cb706213a47798d97/chall.py)

```python:chall.py
#!/usr/bin/python
import binascii
from random import choice

class Cipher:
    BLOCK_SIZE = 16
    ROUNDS = 3
    def __init__(self, key):
        assert(len(key) == self.BLOCK_SIZE*self.ROUNDS)
        self.key = key

    def __block_encrypt(self, block):
        enc = int.from_bytes(block, "big")
        for i in range(self.ROUNDS):
            k = int.from_bytes(self.key[i*self.BLOCK_SIZE:(i+1)*self.BLOCK_SIZE], "big")
            enc &= k
            enc ^= k
        return hex(enc)[2:].rjust(self.BLOCK_SIZE*2, "0")


    def __pad(self, msg):
        if len(msg) % self.BLOCK_SIZE != 0:
            return msg + (bytes([0]) * (self.BLOCK_SIZE - (len(msg) % self.BLOCK_SIZE)))
        else:
            return msg
    
    def encrypt(self, msg):
        m = self.__pad(msg)
        e = ""
        for i in range(0, len(m), self.BLOCK_SIZE):
            e += self.__block_encrypt(m[i:i+self.BLOCK_SIZE])
        return e.encode()

key = binascii.unhexlify("".join([choice(list("abcdef0123456789")) for a in range(Cipher.BLOCK_SIZE*Cipher.ROUNDS*2)]))

with open("flag", "rb") as f:
    flag = f.read()

cipher = Cipher(key)


while True:
    a = input("Would you like to encrypt [1], or try encrypting [2]? ")
    if a == "1":

        p = input("What would you like to encrypt: ")
        try:
            print(cipher.encrypt(binascii.unhexlify(p)).decode())
        except:
            print("Invalid input. ")
    elif a == "2":
        for i in range(10):
            p = "".join([choice(list("abcdef0123456789")) for a in range(64)])
            print("Encrypt this:", p)
            e = cipher.encrypt(binascii.unhexlify(p)).decode()
            c = input()
            if e != c:
                print("L")
                exit()
        print("W")
        print(flag.decode())            

    elif a.lower() == "quit":
        print("Bye")
        exit()
    else:
        print("Invalid input. ")
```

### è§£èª¬
#### ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å•é¡Œç‚¹
ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯`BLOCK_SIZE * ROUND`é•·ã®éµã‚’ä½¿ã£ã¦æš—å·åŒ–ã‚’ã—ã¦ã„ã¾ã™ãŒã€åŒã˜éµã«å¯¾ã—ã¦ä»»æ„ã®æš—å·åŒ–çµæœã‚’çŸ¥ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚ã‚ˆãã“ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚€ã¨åˆ†ã‹ã‚‹ã®ã§ã™ãŒã€æš—å·åŒ–ã¯`&`åŠã³`^`ã®ã¿ã‚’ç”¨ã„ã¦ã„ã‚‹ã“ã¨ã‹ã‚‰ãƒ“ãƒƒãƒˆåˆ¥ã«å‡¦ç†ãŒå®Œå…¨ã«åˆ†ã‹ã‚Œã¦ã—ã¾ã£ã¦ã„ã¾ã™ã€‚

ã“ã®ã“ã¨ã‹ã‚‰ã€å„ãƒ“ãƒƒãƒˆç‹¬ç«‹ã«`0`ã®æ™‚ã®æš—å·åŒ–çµæœã¨`1`ã®æ™‚ã®æš—å·åŒ–çµæœãŒåˆ†ã‹ã£ãŸå ´åˆã€ãã®çµæœã‚’ä»–ã®æš—å·åŒ–å‡¦ç†ã§ã‚‚æµç”¨ãŒå‡ºæ¥ã¾ã™ã€‚ã‚ˆã£ã¦ã€æš—å·æ©Ÿã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚

å®Ÿéš›ã«å®Ÿè£…ã™ã‚‹éš›ã«ã€é–¢æ•°ã‚’`BLOCK_SIZE * 8`å€‹ç”¨æ„ã™ã‚‹ã®ã¯å®Ÿè£…ã®éƒ½åˆä¸Šé¢å€’ãªã®ã§ã€1æ–‡å­—=8byteï¼ˆæ­£ç¢ºã«ã¯16é€²æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã‚‹ãŸã‚ã€16é€šã‚Šï¼‰æ¯ã«å‡ºåŠ›çµæœã‚’ã¾ã¨ã‚ã‚‹å½¢ã§å•é¡Œãªã„ã§ã™ã€‚

```python:solve.pyfrom pwn import *
import binascii

context.log_level = "debug"

r = remote("crypto.2021.chall.actf.co", 21602)
r.recvuntil(b"Would you like to encrypt [1], or try encrypting [2]? ")

# got encryption system
r.sendline(b"1")
r.recvuntil(b"What would you like to encrypt: ")
chars = "0123456789abcdef"
payload = b""
for c in chars:
    payload += c.encode() * 32
r.sendline(payload)
result = r.recvline().decode().strip()

encrypt = [{} for _ in range(32)]
for i in range(len(chars)):
    for j in range(32):
        encrypt[j][chars[i]] = result[32 * i + j]

test = ""
payload = payload.decode()
for i in range(len(payload)):
    test += encrypt[i % 32][payload[i]]
assert test == result

# solve it
r.recvuntil(b"Would you like to encrypt [1], or try encrypting [2]? ")
r.sendline(b"2")
for _ in range(10):
    r.recvuntil("Encrypt this: ")
    p = r.recvline().decode().strip()
    while len(p) % 32 != 0:
        p += "0"
    payload = ""
    for i in range(len(p)):
        payload += encrypt[i % 32][p[i]]
    r.sendline(payload.encode())
r.interactive()
```