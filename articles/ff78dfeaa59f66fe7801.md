---
title: "justCTF 2020 - 25519"
emoji: "ğŸ¡"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["CTF", "Crypto", "Easy"]
published: true
---

## å•é¡Œæ¦‚è¦
> One time signatures, so you can spend your coins only once.
> 
> Please solve the task locally first and reach our server only for the flag :)
> 
> ```
> nc c25519.nc.jctf.pro 1337
> ```
> - https://ams3.digitaloceanspaces.com/justctf/6f7420f1-b591-47a0-98f2-40fd097c33de/task.sage

```python:task.sage
#!/use/bin/env sage

from sys import exit
from hashlib import sha256


FLAG = open('./flag.txt').read()

ec = EllipticCurve(GF(2**255-19), [0, 486662, 0, 1, 0])
p = ec.order()
ZmodP = Zmod(p)
G = ec.lift_x(9)

ha = lambda x: x if isinstance(x, int) or isinstance(x, Integer) else product(x.xy())
hashs = lambda *x: int.from_bytes(sha256(b'.'.join([b'%X' % ha(x) for x in x])).digest(), 'little') % p


def hashp(x):
    x = hashs((x))
    while True:
        try:
            return ec.lift_x(x)
        except:
            x = hashs((x))


def keygen():
    x = randint(1, p-1)
    P = x * G
    return x, P


def verify(signature, P, m):
    I, e, s = signature
    return e == hashs(m, s*G + e*P, s*hashp(P) + e*I)


if __name__ == "__main__":
    x, P = keygen()
    m = randint(1, p-1)
    print(x, P, m)

    spent = set()
    for i in range(8):
        Ix = int(input('I (x): '))
        Iy = int(input('I (y): '))
        I = ec(Ix, Iy)
        e = int(input('e: '))
        s = int(input('s: '))
        if verify((I, e, s), P, m) and I not in spent:
            print('ok')
            spent.add(I)
        else:
            print('nope')
            exit(1)

    print(FLAG)
```

åå‰é€šã‚Šã€Curve25519ã«é–¢ã™ã‚‹å•é¡Œã®ã‚ˆã†ã§ã™ã€‚

## è§£èª¬
ã“ã®å•é¡Œã§ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªæ¡ä»¶ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚

- æ¥•å††æ›²ç·š$y^2=x^3+48662x^2+x$ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã€‚$G$ã¯ã“ã®æ¥•å††æ›²ç·šä¸Šã®åŸºç‚¹ã§ã€$G_x=9$ã€‚[Wikipedia](https://ja.wikipedia.org/wiki/Curve25519)è¦‹ã‚‹ã¨åˆ†ã‹ã‚Šã¾ã™ãŒã€ä½æ•°$p$ãŒã¨ã¦ã‚‚å¤§ãã„ã§ã™ã€‚
- ã‚µãƒ¼ãƒãƒ¼ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã«$x$ã¨$P$ã€ä¹±æ•°$m$ãŒä¸ãˆã‚‰ã‚Œã‚‹ã€‚ã“ã“ã§ã€$P=xG$ã¨ã„ã†é–¢ä¿‚æ€§ãŒã‚ã‚‹ã€‚
- ã“ã®çŠ¶æ…‹ã§ã€ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’8å›ç¹°ã‚Šè¿”ã™ã€‚çªç ´ã§ãã‚Œã°ãƒ•ãƒ©ã‚°ã‚’ãã‚Œã‚‹ã€‚
  1. ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦ã€æ¥•å††æ›²ç·šä¸Šã®ç‚¹$I=(I_x, I_y)$ã¨æ•´æ•°$e$ã€$s$ãŒè¦æ±‚ã•ã‚Œã‚‹ã€‚
  2. $I$ãŒã¾ã ã“ã®ç¹°ã‚Šè¿”ã—ã®ä¸­ã§æœªä½¿ç”¨ã§ã‚ã‚Šã€ã‹ã¤$e=H_s(m, sG+eP, sH_p(P)+eI)$ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã€‚ã“ã“ã§ã€$H_s$ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸Šã«ãŠã‘ã‚‹`hashs`ã€$H_p$ã¯`hashp`ã§ã™ã€‚
  3. $I$ã‚’2ã®åˆ¤å®šã§ç”¨ã„ã‚‹æ—¢å‡ºãƒªã‚¹ãƒˆã«è¿½åŠ 

ä¸€è¦‹ã‹ãªã‚Šè‡ªç”±åº¦ãŒé«˜ãã†ã§ã™ãŒã€ãƒãƒƒã‚·ãƒ¥é–¢æ•°ãŒã‹ãªã‚Šé‚ªé­”ãªå°è±¡ã§ã™ã€‚æ¡ä»¶å¼ã§ã€Œä¸¡è¾ºã«$e$ãŒå­˜åœ¨ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã‹ã‚‰ã€ã“ã‚Œã‚’ç„¡ãã•ãªã„ã“ã¨ã«ã¯å…ˆã«é€²ã‚ã¾ã›ã‚“ã€‚

ã¨ã„ã†ã“ã¨ã§ã€$sG+eP=\alpha G$ã€$sH_p(P)+eI=\beta G$ã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿$(\alpha, \beta)$ã‚’è¿½åŠ ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

- $P=xG$ã‚ˆã‚Š$(s+ex)G=\alpha G$ã€ã¤ã¾ã‚Š$s+ex=\alpha$ã€‚ã“ã‚Œã¯$\alpha$ã€$\beta$ã«ã‚ˆã‚Šãƒãƒƒã‚·ãƒ¥å€¤ãŒç¢ºå®šã—ã¦$e$ãŒæ±‚ã¾ã‚Šã€ãã®å¾Œã«$s$ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚
- 2ã¤ç›®ã®å¼ã¯æ®‹ã£ãŸè‡ªç”±åº¦ã®$I$ã‚’ç¢ºå®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã€$I=e^{-1}(\beta G-sH_p(P))$ã¨å¤‰å½¢ã™ã‚‹ã¨$I$ãŒæ±‚ã¾ã‚Šã¾ã™ã€‚

ã¤ã¾ã‚Šã€å¿…è¦ãªæ‰‹é †ã¨ã—ã¦ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

1. $0$~$p-1$ã®é–“ã®ä¹±æ•°$\alpha$ã€$\beta$ã‚’ç”Ÿæˆã™ã‚‹
2. $e=H_s(m, \alpha G, \beta G)$ã‹ã‚‰$e$ã‚’æ±‚ã‚ã‚‹
3. $s+ex=\alpha$ã‚ˆã‚Š$s$ã‚’æ±‚ã‚ã‚‹
4. $I\equiv e^{-1}(\beta G-sH_p(P))(\mod p)$ã‹ã‚‰$I$ã‚’æ±‚ã‚ã‚‹ã€‚$p$ã¯å°‘ãªãã¨ã‚‚å¶æ•°ã§ã‚ã‚‹ã“ã¨ã‹ã‚‰ã€$e$ã®é€†å…ƒãŒæ±‚ã¾ã‚‰ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã€ãã®å ´åˆã¯1ã‹ã‚‰ã‚„ã‚Šç›´ã—

ä¸‹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ç‰¹ã«$I$ã®é‡è¤‡ã«ã¤ã„ã¦ã¯ä½•ã‚‚è€ƒãˆã¦ã„ã¾ã›ã‚“ãŒã€ã¾ãè¡çªã—ãªã„ã®ã§å¤§ä½“é€šã‚Šã¾ã™ï¼ˆç„¡æ€è€ƒï¼‰

```python:solve.py
from hashlib import sha256
from sage.all import *
import pwn

ec = EllipticCurve(GF(2**255-19), [0, 486662, 0, 1, 0])
p = ec.order()
ZmodP = Zmod(p)
G = ec.lift_x(Integer(9))

ha = lambda x: x if isinstance(x, int) or isinstance(x, Integer) else product(x.xy())
hashs = lambda *x: int.from_bytes(sha256(b'.'.join([b'%X' % ha(x) for x in x])).digest(), 'little') % p

def hashp(x):
  x = hashs((x))
  while True:
    try:
      return ec.lift_x(x)
    except:
      x = hashs((x))

io = pwn.remote("c25519.nc.jctf.pro", 1337)
line = io.recvline().decode('utf-8').split()
x = int(line[0])
P = x * G
m = int(line[-1])

# required: I(Ix, Iy), s, e
for _ in range(8):
  while True:
    try:
      a = randint(0, p - 1)
      b = randint(0, p - 1)
      e = hashs(m, a*G, b*G)
      s = a - e*x
      I = inverse_mod(e, p) * (b*G - s*hashp(P))
      print(io.recvuntil("I (x):").decode('utf-8'), I.xy()[0])
      io.sendline(str(I.xy()[0]).encode('utf-8'))
      print(io.recvuntil("I (y):").decode('utf-8'), I.xy()[1])
      io.sendline(str(I.xy()[1]).encode('utf-8'))
      print(io.recvuntil("e:").decode('utf-8'), e)
      io.sendline(str(e).encode('utf-8'))
      print(io.recvuntil("s:").decode('utf-8'), s)
      io.sendline(str(s).encode('utf-8'))
      break
    except:
      pass
io.interactive()
```

```bash
sage@7d301c35aaf1:/tmp/25519$ python3 solve.sage
[+] Opening connection to c25519.nc.jctf.pro on port 1337: Done
I (x): 15173548547438417837958538934901226118009749756988789082285890307420506692795
 I (y): 56010349933474948589592027095481854451317796359560057433094116023175606374790
 e: 43081426461778073251499005572182999111754544017489573471475548538573001097637
 s: -225427771218132659323468449082112079082542799329884737617792361341164430160707770336746244318540309044763701281261585437307840570453082186386951568079861
 ok
...(çœç•¥)
I (x): 42783616650181984940055861578652434892199983643867742392490150628181143704860
 I (y): 4512726711869550603856915854493443762971126203518057901457635611931940804164
 e: 39473473736355715013237497914980618017872847794800280213346620493410343326331
 s: -206548806235997260660213694695955550140095474232589479026997243191911072360145415465891454905282956075072096388288781547483892779920488241579757111479959
[*] Switching to interactive mode
 ok
jCTF{th1s_g4me_st0p_on1y_onc3}

[*] Got EOF while reading in interactive
```

## æ„Ÿæƒ³
ã‹ãªã‚Šã®æ™‚é–“ã‚’ã€Œãƒãƒƒã‚·ãƒ¥ã©ã†ã—ã‚ˆã†...ä¸¡è¾ºã«$e$ã‚ã‚‹ã‚“ã˜ã‚ƒç„¡ç†ã§ã¯ï¼Ÿï¼Ÿï¼Ÿã€ã¨ã„ã†æ™‚é–“ã«ä½¿ã£ã¦ã¾ã—ãŸã€‚Cryptoã¯ã‚‚ã£ã¨é ‘å¼µã‚ŠãŸã„ã§ã™ã€‚

